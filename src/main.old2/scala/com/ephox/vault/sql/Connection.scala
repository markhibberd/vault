package com.ephox
package vault
package sql

import java.sql.{Connection => C}
import java.sql.{ResultSet => R}
import SqlT._
import XSqlT._
import ISqlT._
import SqlError._
import scalaz._, Scalaz._
import collection.JavaConversions._

sealed trait Connection {
  private[sql] val x: java.sql.Connection

  import Connection._

  def clearWarnings: Sql[Unit] =
    Try(x.clearWarnings)

  def close: Sql[Unit] =
    Try(x.close)

  def commit: Sql[Unit] =
    Try(x.commit)

  def createStatement(s: ResultSety): Sql[Statement] =
    Try(Statement(s.value match {
      case None => x.createStatement
      case Some((t, c, None)) => x.createStatement(t.int, c.int)
      case Some((t, c, Some(h))) => x.createStatement(t.int, c.int, h.int)
    }))

  def autoCommit: Sql[Boolean] =
    Try(x.getAutoCommit)

  def catalog: XSql[String] =
    XTry(x.getCatalog)

  def holdability: ISql[ResultSetHoldability] =
    Try(x.getHoldability) ! (c =>
      if(c == R.HOLD_CURSORS_OVER_COMMIT)
        ResultSetHoldability.HoldsCursorsOverCommit.right
      else if(c == R.CLOSE_CURSORS_AT_COMMIT)
        ResultSetHoldability.CloseCursorsAtCommit.right
      else
        Incompatibility(c, "http://docs.oracle.com/javase/1.5.0/docs/api/java/sql/Connection.html#getHoldability()", "Returns: the holdability, one of ResultSet.HOLD_CURSORS_OVER_COMMIT or ResultSet.CLOSE_CURSORS_AT_COMMIT").left)

  def metadata: Sql[DatabaseMetaData] =
    Try(DatabaseMetaData(x.getMetaData))

  def transactionIsolation: ISql[TransactionIsolation] =
    Try(x.getTransactionIsolation) ! (c =>
      if(c == C.TRANSACTION_READ_UNCOMMITTED)
        TransactionIsolation.ReadUncommitted.right
      else if(c == C.TRANSACTION_READ_COMMITTED)
        TransactionIsolation.ReadCommitted.right
      else if(c == C.TRANSACTION_REPEATABLE_READ)
        TransactionIsolation.RepeatableRead.right
      else if(c == C.TRANSACTION_SERIALIZABLE)
        TransactionIsolation.Serializable.right
      else if(c == C.TRANSACTION_NONE)
        TransactionIsolation.None.right
      else
        Incompatibility(c, "http://docs.oracle.com/javase/1.5.0/docs/api/java/sql/Connection.html#getTransactionIsolation()", "Returns: the current transaction isolation level, which will be one of the following constants: Connection.TRANSACTION_READ_UNCOMMITTED, Connection.TRANSACTION_READ_COMMITTED, Connection.TRANSACTION_REPEATABLE_READ, Connection.TRANSACTION_SERIALIZABLE, or Connection.TRANSACTION_NONE.").left)

  def typeMap: Sql[collection.mutable.Map[String, Class[_]]] =
    Try(mapAsScalaMap(x.getTypeMap))

  def warnings: XSql[java.sql.SQLWarning] =
    XTry(x.getWarnings)

  def isClosed: Sql[Boolean] =
    Try(x.isClosed)

  def isReadOnly: Sql[Boolean] =
    Try(x.isReadOnly)

  def nativeSql(sql: String): Sql[String] =
    Try(x.nativeSQL(sql))

  def prepareCall(sql: String, s: ResultSety): Sql[CallableStatement] =
    Try(CallableStatement(s.value match {
      case None => x.prepareCall(sql)
      case Some((t, c, None)) => x.prepareCall(sql, t.int, c.int)
      case Some((t, c, Some(h))) => x.prepareCall(sql, t.int, c.int, h.int)
    }))

  def prepareStatement(sql: String, s: PrepareStatement): Sql[PreparedStatement] =
    Try(PreparedStatement(s.value.fold(
      _.value match {
        case None => x.prepareStatement(sql)
        case Some((t, c, None)) => x.prepareStatement(sql, t.int, c.int)
        case Some((t, c, Some(h))) => x.prepareStatement(sql, t.int, c.int, h.int)
      }
    , _ match {
        case StatementExecute.AutoGeneratedKeys(n) => x.prepareStatement(sql, n)
        case StatementExecute.ColumnIndexes(y) => x.prepareStatement(sql, y.toArray)
        case StatementExecute.ColumnNames(y) => x.prepareStatement(sql, y.toArray)
      }
    )))

  def releaseSavepoint(savepoint: Savepoint): Sql[Unit] =
    Try(x.releaseSavepoint(savepoint.x))

  def rollback(savepoint: Option[Savepoint]): Sql[Unit] =
    Try(savepoint match {
      case None => x.rollback
      case Some(p) => x.rollback(p.x)
    })

  def setAutoCommit(autoCommit: Boolean): Sql[Unit] =
    Try(x.setAutoCommit(autoCommit))

  def setCatalog(catalog: String): Sql[Unit] =
    Try(x.setCatalog(catalog))

  def setHoldability(holdability: ResultSetHoldability): Sql[Unit] =
    Try(x.setHoldability(holdability.int))

  def setReadOnly(autoCommit: Boolean): Sql[Unit] =
    Try(x.setReadOnly(autoCommit))

  def setSavepoint(name: Option[String]): Sql[Savepoint] =
    Try(Savepoint(name match {
      case None => x.setSavepoint
      case Some(n) => x.setSavepoint(n)
    }))

  def setTransactionIsolation(level: TransactionIsolation): Sql[Unit] =
    Try(x.setTransactionIsolation(level.int))

  def setTypeMap(map: collection.mutable.Map[String, Class[_]]): Sql[Unit] =
    Try(x.setTypeMap(map))
}

object Connection {
  def apply(xx: java.sql.Connection): Connection =
    new Connection {
      val x = xx
    }

  sealed trait Transaction
  object Transaction {
    case object None extends Transaction
    case object ReadCommitted extends Transaction
    case object Uncommitted extends Transaction
    case object RepeatableRead extends Transaction
    case object Serializable extends Transaction
  }

  sealed trait ResultSetHoldability {
    import ResultSetHoldability._
    def int: Int =
      this match {
        case HoldsCursorsOverCommit => R.HOLD_CURSORS_OVER_COMMIT
        case CloseCursorsAtCommit => R.CLOSE_CURSORS_AT_COMMIT
      }
  }
  object ResultSetHoldability {
    case object HoldsCursorsOverCommit extends ResultSetHoldability
    case object CloseCursorsAtCommit extends ResultSetHoldability
  }

  sealed trait ResultSety {
    val value: Option[(ResultSetType, ResultSetConcurrency, Option[ResultSetHoldability])]
  }

  object ResultSety {
    def apply(): ResultSety =
      new ResultSety {
        val value = None
      }

    def typeConcurrency(t: ResultSetType, c: ResultSetConcurrency): ResultSety =
      new ResultSety {
        val value = Some(t, c, None)
      }

    def typeConcurrencyHoldability(t: ResultSetType, c: ResultSetConcurrency, h: ResultSetHoldability): ResultSety =
      new ResultSety {
        val value = Some(t, c, Some(h))
      }
  }

  sealed trait PrepareStatement {
    val value: ResultSety \/ StatementExecute
  }

  object PrepareStatement {
    def apply(y: ResultSety): PrepareStatement =
      new PrepareStatement {
        val value = y.left
      }

    def autoGeneratedKeys(n: Int): PrepareStatement =
      new PrepareStatement {
        val value = StatementExecute.AutoGeneratedKeys(n).right
      }

    def columnIndexes(x: List[Int]): PrepareStatement =
      new PrepareStatement {
        val value = StatementExecute.ColumnIndexes(x).right
      }

    def columnNames(x: List[String]): PrepareStatement =
      new PrepareStatement {
        val value = StatementExecute.ColumnNames(x).right
      }
  }
}
