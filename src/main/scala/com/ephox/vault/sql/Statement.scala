package com.ephox
package vault
package sql

import java.sql.{ResultSet => R}
import SqlT._
import scalaz._, Scalaz._

sealed trait Statement {
  private[sql] val x: java.sql.Statement

  import Statement._

  def addBatch(sql: String): Sql[Unit] =
    Try(x.addBatch(sql))

  def cancel: Sql[Unit] =
    Try(x.cancel)

  def clearBatch: Sql[Unit] =
    Try(x.clearBatch)

  def clearWarnings: Sql[Unit] =
    Try(x.clearWarnings)

  def close: Sql[Unit] =
    Try(x.close)

  def execute(sql: String, c: Option[StatementExecute]): Sql[Boolean] =
    Try(c match {
      case None => x.execute(sql)
      case Some(StatementExecute.AutoGeneratedKeys(n)) => x.execute(sql, n)
      case Some(StatementExecute.ColumnIndexes(i)) => x.execute(sql, i.toArray)
      case Some(StatementExecute.ColumnNames(i)) => x.execute(sql, i.toArray)
    })

  def executeBatch: Sql[List[Int]] =
    Try(x.executeBatch.toList)

  def executeQuery(sql: String): Sql[ResultSet] =
    Try(ResultSet(x.executeQuery(sql)))

  def executeUpdate(sql: String, c: Option[StatementExecute]): Sql[Int] =
    Try(c match {
      case None => x.executeUpdate(sql)
      case Some(StatementExecute.AutoGeneratedKeys(n)) => x.executeUpdate(sql, n)
      case Some(StatementExecute.ColumnIndexes(i)) => x.executeUpdate(sql, i.toArray)
      case Some(StatementExecute.ColumnNames(i)) => x.executeUpdate(sql, i.toArray)
    })

  def connection: Sql[Connection] =
    Try(Connection(x.getConnection))

  def fetchDirection: Sql[FetchDirection] =
    Try(x.getFetchDirection) map (c =>
      if(c == R.FETCH_FORWARD)
        FetchDirection.Forward
      else if(c == R.FETCH_REVERSE)
        FetchDirection.Reverse
      else if(c == R.FETCH_UNKNOWN)
        FetchDirection.Unknown
      else
        error("incompatibility")
      )
}

object Statement {
  def apply(xx: java.sql.Statement): Statement =
    new Statement {
      val x = xx
    }

  sealed trait FetchDirection {
    import FetchDirection._
    def int: Int =
      this match {
        case Forward => R.FETCH_FORWARD
        case Reverse => R.FETCH_REVERSE
        case Unknown => R.FETCH_UNKNOWN
      }
  }

  object FetchDirection {
    case object Forward extends FetchDirection
    case object Reverse extends FetchDirection
    case object Unknown extends FetchDirection
  }
}
