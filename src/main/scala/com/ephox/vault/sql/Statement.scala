package com.ephox
package vault
package sql

import java.sql.{ResultSet => R, Statement => S}
import SqlT._
import XSqlT._
import scalaz._, Scalaz._

sealed trait Statement {
  private[sql] val x: java.sql.Statement

  import Statement._

  def addBatch(sql: String): Sql[Unit] =
    Try(x.addBatch(sql))

  def cancel: Sql[Unit] =
    Try(x.cancel)

  def clearBatch: Sql[Unit] =
    Try(x.clearBatch)

  def clearWarnings: Sql[Unit] =
    Try(x.clearWarnings)

  def close: Sql[Unit] =
    Try(x.close)

  def execute(sql: String, c: Option[StatementExecute]): Sql[Boolean] =
    Try(c match {
      case None => x.execute(sql)
      case Some(StatementExecute.AutoGeneratedKeys(n)) => x.execute(sql, n)
      case Some(StatementExecute.ColumnIndexes(i)) => x.execute(sql, i.toArray)
      case Some(StatementExecute.ColumnNames(i)) => x.execute(sql, i.toArray)
    })

  def executeBatch: Sql[List[Int]] =
    Try(x.executeBatch.toList)

  def executeQuery(sql: String): Sql[ResultSet] =
    Try(ResultSet(x.executeQuery(sql)))

  def executeUpdate(sql: String, c: Option[StatementExecute]): Sql[Int] =
    Try(c match {
      case None => x.executeUpdate(sql)
      case Some(StatementExecute.AutoGeneratedKeys(n)) => x.executeUpdate(sql, n)
      case Some(StatementExecute.ColumnIndexes(i)) => x.executeUpdate(sql, i.toArray)
      case Some(StatementExecute.ColumnNames(i)) => x.executeUpdate(sql, i.toArray)
    })

  def connection: Sql[Connection] =
    Try(Connection(x.getConnection))

  def fetchDirection: Sql[FetchDirection] =
    Try(x.getFetchDirection) map (c =>
      if(c == R.FETCH_FORWARD)
        FetchDirection.Forward
      else if(c == R.FETCH_REVERSE)
        FetchDirection.Reverse
      else if(c == R.FETCH_UNKNOWN)
        FetchDirection.Unknown
      else
        sys.error("[" + c + """] http://docs.oracle.com/javase/1.5.0/docs/api/java/sql/Statement.html#setFetchDirection%28int%29""")
      )

  def fetchSize: Sql[Int] =
    Try(x.getFetchSize)

  def generatedKeys: Sql[ResultSet] =
    Try(ResultSet(x.getGeneratedKeys))

  def maxFieldSize: Sql[Int] =
    Try(x.getMaxFieldSize)

  def maxRows: Sql[Int] =
    Try(x.getMaxRows)

  def moreResults(r: Option[MoreResults]): Sql[Boolean] =
    Try(r match {
      case None => x.getMoreResults
      case Some(q) => x.getMoreResults(q.int)
    })

  def queryTimeout: Sql[Int] =
    Try(x.getQueryTimeout)

  def resultSet: Sql[ResultSet] =
    Try(ResultSet(x.getResultSet))

  def resultSetConcurrency: Sql[ResultSetConcurrency] =
    Try(x.getResultSetConcurrency) map (c =>
      if(c == R.CONCUR_READ_ONLY)
        ResultSetConcurrency.ReadOnly
      else if(c == R.CONCUR_UPDATABLE)
        ResultSetConcurrency.Updatable
      else
        sys.error("[" + c + """] http://docs.oracle.com/javase/1.5.0/docs/api/java/sql/Statement.html#getResultSetConcurrency%28%29""")
      )

  import Connection._
  def resultSetHoldability: Sql[ResultSetHoldability] =
    Try(x.getResultSetHoldability) flatMap (c =>
      if(c == R.HOLD_CURSORS_OVER_COMMIT)
        SqlT.Value[Id, ResultSetHoldability](ResultSetHoldability.HoldsCursorsOverCommit)
      else if(c == R.CLOSE_CURSORS_AT_COMMIT)
        SqlT.Value[Id, ResultSetHoldability](ResultSetHoldability.CloseCursorsAtCommit)
      else
        sys.error("[" + c + """] http://docs.oracle.com/javase/1.5.0/docs/api/java/sql/Statement.html#getResultSetHoldability%28%29 Returns: either ResultSet.HOLD_CURSORS_OVER_COMMIT or ResultSet.CLOSE_CURSORS_AT_COMMIT"""))

  def resultSetType: Sql[ResultSetType] =
    Try(x.getResultSetType) map (c =>
      if(c == R.TYPE_FORWARD_ONLY)
        ResultSetType.ForwardOnly
      else if(c == R.TYPE_SCROLL_INSENSITIVE)
        ResultSetType.ScrollInsensitive
      else if(c == R.TYPE_SCROLL_SENSITIVE)
        ResultSetType.ScrollSensitive
      else
        sys.error("[" + c + """] http://docs.oracle.com/javase/1.5.0/docs/api/java/sql/Statement.html#getResultSetHoldability%28%29 Returns: either ResultSet.HOLD_CURSORS_OVER_COMMIT or ResultSet.CLOSE_CURSORS_AT_COMMIT"""))

  def updateCount: Sql[Int] =
    Try(x.getUpdateCount)

  def warnings: XSql[java.sql.SQLWarning] =
    TryNull(x.getWarnings)

  def setCursorName(name: String): Sql[Unit] =
    Try(x.setCursorName(name))

  def setEscapeProcessing(enable: Boolean): Sql[Unit] =
    Try(x.setEscapeProcessing(enable))

  def setFetchDirection(direction: FetchDirection): Sql[Unit] =
    Try(x.setFetchDirection(direction.int))

  def setFetchSize(rows: Int): Sql[Unit] =
    Try(x.setFetchSize(rows))

  def setMaxFieldSize(max: Int): Sql[Unit] =
    Try(x.setMaxFieldSize(max))

  def setMaxRows(max: Int): Sql[Unit] =
    Try(x.setMaxRows(max))

  def setQueryTimeout(seconds: Int): Sql[Unit] =
    Try(x.setQueryTimeout(seconds))

}

object Statement {
  def apply(xx: java.sql.Statement): Statement =
    new Statement {
      val x = xx
    }

  sealed trait MoreResults {
    import MoreResults._
    def int: Int =
      this match {
        case CloseCurrentResult => S.CLOSE_ALL_RESULTS
        case KeepCurrentResult => S.KEEP_CURRENT_RESULT
        case CloseAllResults => S.CLOSE_ALL_RESULTS
      }
  }

  object MoreResults {
    case object CloseCurrentResult extends MoreResults
    case object KeepCurrentResult extends MoreResults
    case object CloseAllResults extends MoreResults
  }

  sealed trait ResultSetConcurrency {
    import ResultSetConcurrency._
    def int: Int =
      this match {
        case ReadOnly => R.CONCUR_READ_ONLY
        case Updatable => R.CONCUR_UPDATABLE
      }
  }

  object ResultSetConcurrency {
    case object ReadOnly extends ResultSetConcurrency
    case object Updatable extends ResultSetConcurrency
  }

}
